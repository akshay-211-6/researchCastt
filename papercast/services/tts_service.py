"""
services/tts_service.py — Converts dialogue into audio via ElevenLabs, with synthetic fallback.
"""
from __future__ import annotations

import asyncio
import io
import logging
import re
import os
import random
from dataclasses import dataclass


class TTSFailure(Exception):
    """Raised when text‑to‑speech cannot be completed with the ElevenLabs API."""

import httpx
from pydub import AudioSegment
from pydub.generators import Sine
from config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

# ── Constants ─────────────────────────────────────────────────────────────────
ELEVENLABS_BASE = "https://api.elevenlabs.io/v1"
TTS_MODEL       = "eleven_turbo_v2"
PAUSE_HOST_SWITCH = 600  # ms gap between speakers

@dataclass
class SynthesisedLine:
    host: str
    text: str
    audio: AudioSegment
    duration_ms: int
    synthetic: bool = False  # True if the audio was generated by the fallback tone generator

# ── Public API ────────────────────────────────────────────────────────────────

async def synthesise_script(script_text: str, voice_pair: str = "FM") -> list[SynthesisedLine]:
    """
    Parses the raw Gemini string and synthesises it line-by-line.

    If the ElevenLabs service fails (bad key/voice id, network problem, etc.)
    we now propagate an exception back to the caller instead of quietly
    returning the synthetic demo audio that produces beeps.  The caller
    (_run_pipeline) will catch the exception and mark the job as errored.
    """
    # 1. Parse the raw string into a list of (Host, Text)
    # The regex is intentionally permissive so slight formatting changes don't
    # break the pipeline.
    pattern = re.compile(r"(?:Host\s*([AB])\s*[:\-]|(?:\*\*Host\s*([AB])\*\*\s*[:\-]))\s*(.*)", re.IGNORECASE)
    lines = []
    
    for match in pattern.finditer(script_text):
        host = match.group(1) or match.group(2)
        text = match.group(3).strip()
        if host and text:
            lines.append({"host": host.upper(), "text": text})

    if not lines:
        # nothing to synthesise; caller may want to troubleshoot Gemini output
        logger.error("Could not parse any dialogue from Gemini output.")
        return []

    # 2. Assign voices from config
    voice_a, voice_b = settings.voice_ids_for_pair(voice_pair)
    voice_map = {"A": voice_a, "B": voice_b}
    
    synthesised: list[SynthesisedLine] = []

    async with httpx.AsyncClient(timeout=60.0) as http:
        for idx, item in enumerate(lines):
            voice_id = voice_map.get(item["host"], voice_a)
            
            logger.info(f"Synthesising line {idx+1}/{len(lines)} for Host {item['host']}")
            audio, synthetic = await _tts_with_retry(http, voice_id, item["text"])

            synthesised.append(SynthesisedLine(
                host=item["host"],
                text=item["text"],
                audio=audio,
                duration_ms=len(audio),
                synthetic=synthetic,
            ))
            
            # Rate limit protection
            await asyncio.sleep(0.2)

    return synthesised

# ── Internal Helpers ──────────────────────────────────────────────────────────

async def _tts_with_retry(http: httpx.AsyncClient, voice_id: str, text: str) -> AudioSegment:
    url = f"{ELEVENLABS_BASE}/text-to-speech/{voice_id}"
    headers = {
        "xi-api-key": settings.elevenlabs_api_key,
        "Content-Type": "application/json",
    }
    payload = {
        "text": text,
        "model_id": TTS_MODEL,
        "voice_settings": {"stability": 0.5, "similarity_boost": 0.75}
    }

    # If no API key is configured we fall back to the demo tone generator up
    # front; callers should be aware that the output will be beeps rather than
    # real speech.
    if not settings.elevenlabs_api_key:
        logger.warning("ElevenLabs API key is missing; using synthetic demo audio")
        return _generate_synthetic_speech(text), True

    for attempt in range(3):
        try:
            resp = await http.post(url, headers=headers, json=payload)
            if resp.status_code == 429:
                # rate limited, retry with backoff
                await asyncio.sleep(2 ** attempt)
                continue

            # on any other non-2xx status we want to stop rather than silently
            # falling back.  Include response text because invalid voice IDs are
            # a very common misconfiguration.
            if resp.status_code != 200:
                body = resp.text[:200]
                raise TTSFailure(f"ElevenLabs returned {resp.status_code}: {body}")

            audio = AudioSegment.from_file(io.BytesIO(resp.content), format="mp3")
            return audio, False
        except TTSFailure:
            # bubble our custom exception immediately
            raise
        except Exception as e:
            logger.warning(f"TTS attempt {attempt+1} failed: {e}")
            if attempt == 2:
                # last chance; propagate failure so pipeline can abort
                raise TTSFailure("Failed to contact ElevenLabs text-to-speech API")
            await asyncio.sleep(1)

    # should never be reached, but keep signature consistent
    raise TTSFailure("Unable to synthesise speech")


def _generate_synthetic_speech(text: str) -> AudioSegment:
    """
    Generate synthetic speech-like audio using tones.
    Creates a sequence of tones that vary to simulate human speech.
    """
    # Estimate duration: ~150ms per word
    word_count = len(text.split())
    total_duration_ms = max(1000, word_count * 150)
    
    output = AudioSegment.empty()
    time_ms = 0
    
    while time_ms < total_duration_ms:
        # Vary frequency between 200-800 Hz to simulate speech formants
        freq = random.randint(200, 800)
        # Random syllable duration 100-300ms
        duration = random.randint(100, 300)
        
        # Create tone
        tone = Sine(freq, sample_rate=22050).to_audio_segment(duration=duration)
        # Add slight volume variation
        volume_db = random.uniform(-3, 0)
        tone = tone.apply_gain(volume_db)
        
        output += tone
        
        # Random gaps between syllables 50-150ms
        gap = random.randint(50, 150)
        output += AudioSegment.silent(duration=gap)
        
        time_ms += duration + gap
    
    # Fade in/out for naturalness
    return output.fade_in(100).fade_out(100)